% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dtou.R, R/package.R
\docType{package}
\name{dtou}
\alias{dtou}
\alias{dtou-package}
\title{distance to uniqueness for collection of genetic sequences.}
\usage{
dtou(str, depth = NULL, rc = TRUE, optimizeForSpeed = FALSE)
}
\arguments{
\item{str}{A vector of characters.  Contains genomic sequences comprised of A,C,G,T,X, and N only.}

\item{depth}{A numeric scalar. Limits the max value of the dtou metric.}

\item{rc}{A logical scalar. Indicates whether to take reverse complements into consideration.}

\item{optimizeForSpeed}{A logical scalar. Introduces overhead into the recursion but my increase speed}
}
\value{
A list of numeric vectors containing the \emph{distance to uniqueness} value for each base-pair
}
\description{
\code{dtou} expects that genetic sequences will be represented as character vectors using only the
upper-case characters ACGTNX.  It performs no type-conversions so the input
must already be of type character.

The only function that should be directly invoked is \code{dtou()} which knows how to call the appropriate C functions
}
\details{
For each genetic sequence in the input parameter \code{str}, the function \code{dtou} returns the numeric
\emph{distance to uniqueness} vector for that sequence.

the \emph{distance to uniqueness} is defined for each base-pair in a sequence as the length of the
shortest unique subsequence starting at that base-pair.

The \code{rc} parameter determines whether or not reverse complements are considered when determining what
counts as unique.

Currently \code{dtou} uses recursive function calls and if the collection of genetic sequences in \code{str}
contains overly-long repeats then the system can crash-- including R itself.

There are three variations of the function to help control for this problem.  First, indicating a \code{depth}
Will depth-limit the recursion and cause the dtou metric to return a value no greater than that depth.  A depth
that is too high for the amount of memory in the call-back stack used by the C++ function will still crash the
system.

Secondly, the \code{optimizeForSpeed} option introduces extra over-head into the recursion (thus decreasing the
maximum recursion level) by keeping track of the stack size and switching to an iterative approach when the
copy number of a repetitive region is \strong{two}.  (see the explanatory vignette for more information)
If all long repetitions have copy number two, then the recursion limit is not reached.  This technique is also
faster than the default-- but again, at the cost of reducing the maximum level of recursion.

The third variation combines the previous two.  It is a depth limited optimize-for-speed approach.
}
\section{C functions}{

\code{c_dtou} takes a vector of characters and returns their distance to uniqueness.

\code{c_dtouDepthLimit} is a depth limited version of the previous function.

\code{c_dtouS2} is a variation that may improve speed.

\code{c_dtouS2DepthLimit} is a depth limited version that may also improve speed.
}

\examples{
\donttest{
dtou(c("AAAAACCCGACTGGGCTCA","ACCT"),rc=TRUE)
dtou(c("AAAAACCCGACTGGGCTCA","ACCT"),rc=FALSE)
dtou(c("AAAAACCCGACTGGGCTCA","ACCT"),rc=TRUE,depth=3)
dtou(c("AAAAACCCGACTGGGCTCA","ACCT"),depth=3,optimizeForSpeed=TRUE)
}

}
