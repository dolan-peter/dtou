---
title: "Algorithm Modifications"
author: "Peter Dolan"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{Biostrings}
  %\VignettedDepends{kableExtra}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This will contain an example of modifying the recursion function that is at the heart of the `dtou` algorithm.  The algorithm will be modified to replicate a $k$-mer calculation for the amount of repetitiveness as measured by the number of repeated $k$-mers.  Our version will generate these statistics for all $k$-mers of 1 to 101.

The underlying recursive subroutine used by the algorithm is just below.  The `depth>=d` condition limits the depth of the recursion. It uses several global variables and doesn't do anything except recurse the stack-tree (see [algorithm](Algorithm.html)).  Keeping track of the `stackSize` is often unnecessary and there are variants in the C++ source code that don't keep track of it (every variable not included in a function allows the call-back stack to go that much deeper before a stack overflow).

```{c,eval=FALSE}
void depthLimitedVignetteRecurse(long Ip1, long depth,long stackSize){
	long A1=-1, C1=-1, G1=-1, T1=-1;
	long ASize=0,CSize=0,GSize=0,TSize=0;

	if(depth>d){return;}
	if(Ip1==-1){return;}
	if(Indices[Ip1]==-1){ // Only one entry exists in the stack
		return;
	}
	i=Ip1;
	while(i!=-1){
		next_i=Indices[i];
		switch(str[i+depth]){
		case 'A':
			Indices[i]=A1; A1=i; ASize++;
			break;
		case 'C':
			Indices[i]=C1; C1=i; CSize++;
			break;
		case 'G':
			Indices[i]=G1; G1=i; GSize++;
			break;
		case 'T':
			Indices[i]=T1; T1=i; TSize++;
			break;
		case 'N':	case 'X':
			Indices[i]=-1;
			break;
		}
		i=next_i;
	}
	depthLimitedVignetteRecurse(A1,depth+1,ASize);
	depthLimitedVignetteRecurse(C1,depth+1,CSize);
	depthLimitedVignetteRecurse(G1,depth+1,GSize);
	depthLimitedVignetteRecurse(T1,depth+1,TSize);
	return;
}
```

Here (using a global `counts` variable) is how we record the number of $d$-mers for $0 \le d \le 100$:

```{c,eval=FALSE}
void depthLimitedVignetteRecurse(long Ip1, long depth,long stackSize){
	[...]
	if(depth>d){return;}
	if(Ip1==-1){return;}
	counts[depth]+=stackSize;
	if(Indices[Ip1]==-1){ // Only one entry exists in the stack
		return;
	}
	i=Ip1;
	while(i!=-1){
		[...]
	}
	depthLimitedVignetteRecurse(A1,depth+1,ASize);
	depthLimitedVignetteRecurse(C1,depth+1,CSize);
	depthLimitedVignetteRecurse(G1,depth+1,GSize);
	depthLimitedVignetteRecurse(T1,depth+1,TSize);
	return;
}
```

To begin we'll need a data-set.  I downloaded an ecoli genome ASM584v2 from NCBI and put it in a directory called data.  This next bit doesn't require the `Biostrings` package but it makes it easier to load the fasta file:

```{r,message=FALSE,fig.width=7}
library(Biostrings)
library(dtou)
fn=system.file("extdata","ecoli_str_k_12_substr_mg1655.fa",package="dtou")
ecoli<-readDNAStringSet(fn)
str<-as.character(ecoli)
system.time({results<-c_vignetteExample(str,TRUE)})
n<-30
plot(0:n,results[1:(n+1)]/results[2],xlab="k-mer",ylab="Percentage of repetitiveness",type="b",main="Duplication in ecoli")
```

This could be derived from the `dtou` statistic too:

```{r}
system.time({
	ecoli.dtou<-dtou(str,rc=TRUE)[[1]]
	r2<-sapply(1:100,function(n){sum(ecoli.dtou>=n)})
})
all(results[-1]/2==r2)
```

The second approach puts no aprior upper bound on the $k$-mer size, but it does require loading an array of the same size as the genomic sequence into memory which might be problematic in some situations and the entire calculation takes more than twice as long (although it's still only a few seconds)

## Other variations

Here are some other easy to implement variations:

* Return the array of indices generated by the algorithm when run with a depth-limit
* Return the average distance between hexamers
* Return the distance necessary to find 3 `CG` dimers.
